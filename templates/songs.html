{% extends "base.html" %}

{% block title %}Songs - SoundShare{% endblock %}

{% block content %}
<div class="d-flex justify-content-between align-items-center mb-4">
    <h1>Song Management</h1>
    <div class="btn-group">
        <button class="btn btn-primary" data-bs-toggle="modal" data-bs-target="#addFileModal">
            <i class="fas fa-plus"></i> Add Single Song
        </button>
        <button class="btn btn-success" data-bs-toggle="modal" data-bs-target="#addMultipleModal">
            <i class="fas fa-plus-circle"></i> Add Multiple Songs
        </button>
        <button class="btn btn-info" data-bs-toggle="modal" data-bs-target="#scanDirectoryModal">
            <i class="fas fa-folder-open"></i> Scan Directory
        </button>
    </div>
</div>

<!-- Search and Filter Section -->
<div class="card mb-4">
    <div class="card-body">
        <div class="row">
            <div class="col-md-4">
                <div class="mb-3">
                    <label for="searchInput" class="form-label">Search Songs</label>
                    <input type="text" class="form-control" id="searchInput" placeholder="Search by name, artist, album...">
                </div>
            </div>
            <div class="col-md-3">
                <div class="mb-3">
                    <label for="artistFilter" class="form-label">Filter by Artist</label>
                    <select class="form-select" id="artistFilter">
                        <option value="">All Artists</option>
                    </select>
                </div>
            </div>
            <div class="col-md-2">
                <div class="mb-3">
                    <label for="albumFilter" class="form-label">Filter by Album</label>
                    <select class="form-select" id="albumFilter">
                        <option value="">All Albums</option>
                    </select>
                </div>
            </div>
            <div class="col-md-2">
                <div class="mb-3">
                    <label for="folderFilter" class="form-label">Filter by Folder</label>
                    <select class="form-select" id="folderFilter">
                        <option value="">All Folders</option>
                    </select>
                </div>
            </div>
            <div class="col-md-1">
                <div class="mb-3">
                    <label class="form-label">&nbsp;</label>
                    <div>
                        <button class="btn btn-outline-secondary w-100" onclick="clearFilters()">
                            <i class="fas fa-times"></i> Clear
                        </button>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="row">
            <div class="col-md-3">
                <div class="mb-3">
                    <label for="energyFilter" class="form-label">Energy Range</label>
                    <select class="form-select" id="energyFilter">
                        <option value="">Any Energy</option>
                        <option value="high">High Energy (70%+)</option>
                        <option value="medium">Medium Energy (30-70%)</option>
                        <option value="low">Low Energy (0-30%)</option>
                    </select>
                </div>
            </div>
            <div class="col-md-3">
                <div class="mb-3">
                    <label for="valenceFilter" class="form-label">Mood Range</label>
                    <select class="form-select" id="valenceFilter">
                        <option value="">Any Mood</option>
                        <option value="positive">Positive (70%+)</option>
                        <option value="neutral">Neutral (30-70%)</option>
                        <option value="melancholy">Melancholy (0-30%)</option>
                    </select>
                </div>
            </div>
            <div class="col-md-3">
                <div class="mb-3">
                    <label for="danceabilityFilter" class="form-label">Danceability</label>
                    <select class="form-select" id="danceabilityFilter">
                        <option value="">Any Danceability</option>
                        <option value="high">High Danceability (70%+)</option>
                        <option value="medium">Medium Danceability (30-70%)</option>
                        <option value="low">Low Danceability (0-30%)</option>
                    </select>
                </div>
            </div>
            <div class="col-md-3">
                <div class="mb-3">
                    <label for="durationFilter" class="form-label">Duration</label>
                    <select class="form-select" id="durationFilter">
                        <option value="">Any Duration</option>
                        <option value="sound_effects">Sound Effects (< 10 seconds)</option>
                        <option value="short">Short (< 1 minute)</option>
                        <option value="long">Songs (> 1 minute)</option>
                    </select>
                </div>
            </div>
        </div>
        
        <div class="row">
            <div class="col-md-12">
                <div class="mb-3">
                    <label class="form-label">Song Count</label>
                    <div>
                        <span class="btn btn-outline-info w-100" id="filteredSongCount">0 songs</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Batch Actions Section -->
<div class="card mb-4" id="batchActionsCard" style="display: none;">
    <div class="card-body">
        <div class="row align-items-center">
            <div class="col-md-4">
                <span id="selectedCount" class="fw-bold">0 songs selected</span>
            </div>
            <div class="col-md-8">
                <div class="btn-group">
                    <button class="btn btn-success" onclick="openBatchTagModal()">
                        <i class="fas fa-tags"></i> Batch Tag
                    </button>
                    <button class="btn btn-primary" onclick="openBatchPlaylistModal()">
                        <i class="fas fa-list"></i> Add to Playlist
                    </button>
                    <button class="btn btn-danger" onclick="batchDeleteSongs()">
                        <i class="fas fa-trash"></i> Delete Selected
                    </button>
                    <button class="btn btn-outline-primary" onclick="selectAll()">
                        <i class="fas fa-check-square"></i> Select All
                    </button>
                    <button class="btn btn-outline-secondary" onclick="selectNone()">
                        <i class="fas fa-square"></i> Select None
                    </button>
                    <button class="btn btn-outline-info" onclick="invertSelection()">
                        <i class="fas fa-random"></i> Invert Selection
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>
<div class="row">
    <div class="col-12">
        <div class="card">
            <div class="card-body">
                <table class="table table-striped" id="songsTable">
                    <thead>
                        <tr>
                            <th width="50">
                                <input type="checkbox" id="selectAllCheckbox" onchange="toggleSelectAll()">
                            </th>
                            <th width="250">Name</th>
                            <th width="140">Folder</th>
                            <th width="160">Album</th>
                            <th width="80">Track #</th>
                            <th width="80">Duration</th>
                            <th width="180">Mood</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Songs will be loaded here via JavaScript -->
                    </tbody>
                </table>
            </div>
        </div>
    </div>
</div>


<!-- Add Single File Modal -->
<div class="modal fade" id="addFileModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Add Single Song</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <form id="addFileForm">
                    <div class="mb-3">
                        <label for="filePath" class="form-label">File Path</label>
                        <div class="input-group">
                            <input type="text" class="form-control" id="filePath" placeholder="/path/to/your/song.mp3" required>
                            <input type="file" class="form-control d-none" id="filePathInput" accept="audio/*">
                            <button type="button" class="btn btn-outline-secondary" onclick="selectAudioFile()">
                                <i class="fas fa-folder-open"></i> Browse
                            </button>
                        </div>
                        <div class="form-text">Select an audio file from your system</div>
                    </div>
                    <div class="mb-3">
                        <label for="displayName" class="form-label">Display Name (Optional)</label>
                        <input type="text" class="form-control" id="displayName" placeholder="Leave empty to use filename">
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" onclick="addSingleSong()">Add Song</button>
            </div>
        </div>
    </div>
</div>

<!-- Add Multiple Files Modal -->
<div class="modal fade" id="addMultipleModal" tabindex="-1">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Add Multiple Songs</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <div class="mb-3">
                    <label for="filePathsList" class="form-label">File Paths</label>
                    <div class="mb-2">
                        <input type="file" class="form-control d-none" id="multipleFilesInput" multiple accept="audio/*">
                        <button type="button" class="btn btn-outline-info" onclick="selectMultipleAudioFiles()">
                            <i class="fas fa-folder-open"></i> Select Audio Files
                        </button>
                        <small class="text-muted ms-2">or enter paths manually below</small>
                    </div>
                    <textarea class="form-control" id="filePathsList" rows="10" 
                              placeholder="Enter one file path per line, e.g.:
/path/to/song1.mp3
/path/to/song2.wav
/path/to/song3.flac"></textarea>
                    <div class="form-text">Select multiple audio files or enter one file path per line. Supported formats: MP3, WAV, FLAC, M4A, OGG, WMA</div>
                </div>
                <div class="mb-3">
                    <button type="button" class="btn btn-outline-info" onclick="loadSamplePaths()">
                        <i class="fas fa-lightbulb"></i> Load Example Paths
                    </button>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-success" onclick="addMultipleSongs()">Add All Songs</button>
            </div>
        </div>
    </div>
</div>

<!-- Scan Directory Modal -->
<div class="modal fade" id="scanDirectoryModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Scan Directory for Audio Files</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <form id="scanDirectoryForm">
                    <div class="mb-3">
                        <label for="directoryPath" class="form-label">Directory Path</label>
                        <div class="input-group">
                            <input type="text" class="form-control" id="directoryPath" placeholder="/path/to/music/folder" required>
                            <input type="file" class="form-control d-none" id="directoryInput" webkitdirectory directory>
                            <button type="button" class="btn btn-outline-secondary" onclick="selectDirectory()">
                                <i class="fas fa-folder-open"></i> Browse
                            </button>
                        </div>
                        <div class="form-text">Select a directory containing audio files</div>
                    </div>
                    <div class="mb-3">
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" id="recursiveScan" checked>
                            <label class="form-check-label" for="recursiveScan">
                                Scan subdirectories recursively
                            </label>
                        </div>
                    </div>
                    <div class="alert alert-info">
                        <i class="fas fa-info-circle"></i>
                        This will scan the directory for audio files (MP3, WAV, FLAC, M4A, OGG, WMA) and add them to your library.
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-info" onclick="scanDirectory()">Scan Directory</button>
            </div>
        </div>
    </div>
</div>

<!-- Edit Song Modal -->
<div class="modal fade" id="editModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Edit Song</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <form id="editForm">
                    <input type="hidden" id="editSongId">
                    <div class="mb-3">
                        <label for="editDisplayName" class="form-label">Display Name</label>
                        <input type="text" class="form-control" id="editDisplayName">
                    </div>
                    <div class="mb-3">
                        <label for="editArtist" class="form-label">Artist</label>
                        <input type="text" class="form-control" id="editArtist">
                    </div>
                    <div class="mb-3">
                        <label for="editAlbum" class="form-label">Album</label>
                        <input type="text" class="form-control" id="editAlbum">
                    </div>
                    <div class="mb-3">
                        <label for="editYear" class="form-label">Year</label>
                        <input type="number" class="form-control" id="editYear">
                    </div>
                    <div class="mb-3">
                        <label for="editGenre" class="form-label">Genre</label>
                        <input type="text" class="form-control" id="editGenre">
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" onclick="updateSong()">Save Changes</button>
            </div>
        </div>
    </div>
</div>

<!-- Tag Management Modal -->
<div class="modal fade" id="tagManagementModal" tabindex="-1">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Manage Song Tags</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <input type="hidden" id="tagManagementSongId">
                <div class="mb-4">
                    <h6>Current Tags</h6>
                    <div id="currentTags" class="d-flex flex-wrap gap-2 mb-3" style="min-height: 40px;">
                        <!-- Current tags will be displayed here -->
                    </div>
                </div>
                <div class="mb-3">
                    <h6>Available Tags</h6>
                    <div id="availableTags" class="d-flex flex-wrap gap-2" style="min-height: 40px;">
                        <!-- Available tags will be displayed here -->
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>

<!-- Add to Playlist Modal -->
<div class="modal fade" id="addToPlaylistModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Add Song to Playlist</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <input type="hidden" id="addToPlaylistSongId">
                <div class="mb-3">
                    <label class="form-label">Select Static Playlist</label>
                    <select class="form-select" id="playlistSelectDropdown">
                        <option value="">Choose a playlist...</option>
                        <!-- Playlists will be loaded here -->
                    </select>
                </div>
                <div class="text-center">
                    <small class="text-muted">Only static playlists are shown. Dynamic playlists are based on tags.</small>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" onclick="addSongToSelectedPlaylist()">Add to Playlist</button>
            </div>
        </div>
    </div>
</div>

<!-- Batch Tag Management Modal -->
<div class="modal fade" id="batchTagModal" tabindex="-1">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Batch Tag Management</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <div class="alert alert-info">
                    <i class="fas fa-info-circle"></i>
                    <span id="batchSelectedInfo">0 songs selected</span>
                </div>
                
                <div class="row">
                    <div class="col-md-6">
                        <h6 class="mb-3">Select Tags to Apply</h6>
                        <div id="batchAvailableTags" class="border p-3 rounded" style="min-height: 200px; max-height: 300px; overflow-y: auto;">
                            <!-- Available tags will be displayed here -->
                        </div>
                    </div>
                    <div class="col-md-6">
                        <h6 class="mb-3">Selected Tags</h6>
                        <div id="batchSelectedTags" class="border p-3 rounded" style="min-height: 200px; max-height: 300px; overflow-y: auto;">
                            <!-- Selected tags will be displayed here -->
                        </div>
                    </div>
                </div>
                
                <div class="row mt-4">
                    <div class="col-12">
                        <h6>Tag Operation Mode</h6>
                        <div class="form-check form-check-inline">
                            <input class="form-check-input" type="radio" name="tagOperation" id="tagAdd" value="add" checked>
                            <label class="form-check-label" for="tagAdd">
                                <i class="fas fa-plus text-success"></i> Add Tags (keep existing)
                            </label>
                        </div>
                        <div class="form-check form-check-inline">
                            <input class="form-check-input" type="radio" name="tagOperation" id="tagReplace" value="replace">
                            <label class="form-check-label" for="tagReplace">
                                <i class="fas fa-sync text-warning"></i> Replace Tags (overwrite all)
                            </label>
                        </div>
                        <div class="form-check form-check-inline">
                            <input class="form-check-input" type="radio" name="tagOperation" id="tagRemove" value="remove">
                            <label class="form-check-label" for="tagRemove">
                                <i class="fas fa-minus text-danger"></i> Remove Tags
                            </label>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" onclick="applyBatchTags()">Apply Tags</button>
            </div>
        </div>
    </div>
</div>

<!-- Batch Playlist Modal -->
<div class="modal fade" id="batchPlaylistModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Add Songs to Playlist</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <div class="alert alert-info">
                    <i class="fas fa-info-circle"></i>
                    <span id="batchPlaylistInfo">0 songs selected</span>
                </div>
                <div class="mb-3">
                    <label class="form-label">Select Static Playlist</label>
                    <select class="form-select" id="batchPlaylistSelect">
                    </select>
                </div>
                <div class="text-center">
                    <small class="text-muted">Only static playlists are shown. Dynamic playlists are based on tags.</small>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" onclick="applyBatchPlaylist()">Add to Playlist</button>
            </div>
        </div>
    </div>
</div>

<!-- Undo Notification -->
<div id="undoNotification" class="alert alert-warning alert-dismissible fade" 
     style="position: fixed; top: 20px; right: 20px; z-index: 1055; min-width: 300px; display: none;">
    <div class="d-flex align-items-center justify-content-between">
        <div>
            <i class="fas fa-trash me-2"></i>
            <span id="undoMessage">Song deleted</span>
        </div>
        <div>
            <button type="button" class="btn btn-sm btn-outline-warning me-2" onclick="undoDelete()">
                <i class="fas fa-undo"></i> Undo
            </button>
            <button type="button" class="btn-close" onclick="hideUndoNotification()"></button>
        </div>
    </div>
    <div class="progress mt-2" style="height: 3px;">
        <div id="undoProgressBar" class="progress-bar bg-warning" style="width: 100%; transition: width 5s linear;"></div>
    </div>
</div>

<style>
/* Custom styling for segment buttons to create a continuous bar */
.btn-group .segment-btn {
    border-radius: 0 !important;
    border-right: none !important;
    flex: 1;
    min-height: 50px;
    position: relative;
    transition: all 0.2s ease;
}

.btn-group .segment-btn:first-child {
    border-top-left-radius: 0.375rem !important;
    border-bottom-left-radius: 0.375rem !important;
}

.btn-group .segment-btn:last-child {
    border-top-right-radius: 0.375rem !important;
    border-bottom-right-radius: 0.375rem !important;
    border-right: 1px solid #6c757d !important;
}

.btn-group .segment-btn.btn-success {
    border-right: none !important;
    z-index: 1;
}

.btn-group .segment-btn.btn-success:last-child {
    border-right: 1px solid #198754 !important;
}

.segment-label {
    font-size: 0.8rem;
    font-weight: 500;
}

/* Style for the preview row */
.song-preview-row .card {
    margin: 0;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    border-left: 4px solid #007bff;
}

.song-preview-row .card-body {
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
}

/* Responsive adjustments */
@media (max-width: 768px) {
    .segment-label {
        font-size: 0.7rem;
    }
    
    .btn-group .segment-btn {
        min-height: 40px;
        padding: 0.25rem 0.1rem;
    }
}

/* Audio player styling */
audio {
    height: 40px;
    border-radius: 0.375rem;
}

audio::-webkit-media-controls-panel {
    background-color: #f8f9fa;
}



/* Ensure the full song audio player takes up remaining space in flex container */
.flex-grow-1 {
    flex-grow: 1;
}
</style>

<script>
let songs = [];
let filteredSongs = [];
let tags = [];
let playlists = [];
let selectedSongs = new Set();
let batchSelectedTags = new Set();

// Undo functionality
let undoTimeout = null;
let deletedSong = null;
let deletedSongRow = null;
let undoData = null;

// Load songs and tags on page load
document.addEventListener('DOMContentLoaded', function() {
    loadSongs();
    loadTags();
    loadPlaylists();
    setupFilterListeners();
});

async function loadSongs() {
    try {
        const response = await fetch('/api/songs/');
        songs = await response.json();
        filteredSongs = [...songs];
        populateFilterDropdowns();
        renderSongsTable();
    } catch (error) {
        console.error('Error loading songs:', error);
    }
}

async function loadTags() {
    try {
        const response = await fetch('/api/tags/');
        tags = await response.json();
    } catch (error) {
        console.error('Error loading tags:', error);
    }
}

async function loadPlaylists() {
    try {
        const response = await fetch('/api/playlists/');
        playlists = await response.json();
        populatePlaylistDropdown();
    } catch (error) {
        console.error('Error loading playlists:', error);
    }
}

function populatePlaylistDropdown() {
    const select = document.getElementById('playlistSelectDropdown');
    select.innerHTML = '<option value="">Choose a playlist...</option>';
    
    playlists.forEach(playlist => {
        const option = document.createElement('option');
        option.value = playlist.id;
        option.textContent = playlist.name;
        select.appendChild(option);
    });
}

function renderSongsTable() {
    const tbody = document.querySelector('#songsTable tbody');
    tbody.innerHTML = '';
    
    filteredSongs.forEach(song => {
        const row = document.createElement('tr');
        row.dataset.songId = song.id;
        row.style.cursor = 'pointer';
        
        // Extract folder from file path
        const getFolder = (filePath) => {
            if (!filePath) return '';
            const parts = filePath.split('/');
            if (parts.length > 1) {
                parts.pop(); // Remove filename
                return parts[parts.length - 1]; // Return last folder name
            }
            return '';
        };
        
        // Format duration 
        const formatDuration = (seconds) => {
            if (!seconds) return '';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        };
        
        // COMMENTED OUT: Complex mood calculations for debugging
        const energy = song.energy !== null && song.energy !== undefined ? Math.max((song.energy * 100).toFixed(0), 2) : '0';
        const valence = song.valence !== null && song.valence !== undefined ? Math.max((song.valence * 100).toFixed(0), 2) : '0';
        const danceability = song.danceability !== null && song.danceability !== undefined ? Math.max((song.danceability * 100).toFixed(0), 2) : '0';
        
        // HARDCODED VALUES FOR TESTING
        // const energy = '75';
        // const valence = '60'; 
        // const danceability = '85';
        
        // Enhanced debug logging for first few songs
        if (filteredSongs.indexOf(song) < 3) {
            console.log(`Song ${filteredSongs.indexOf(song) + 1} (${song.display_name}):`, {
                rawValues: { energy: song.energy, valence: song.valence, danceability: song.danceability },
                calculatedValues: { energy, valence, danceability },
                hasData: (song.energy !== null && song.energy !== undefined) || 
                        (song.valence !== null && song.valence !== undefined) || 
                        (song.danceability !== null && song.danceability !== undefined)
            });
        }
        
        const isSelected = selectedSongs.has(song.id);
        
        row.innerHTML = `
            <td onclick="event.stopPropagation()">
                <input type="checkbox" class="song-checkbox" data-song-id="${song.id}" 
                       ${isSelected ? 'checked' : ''} onchange="toggleSongSelection(${song.id})">
            </td>
            <td class="song-name-cell" title="${song.display_name}" style="max-width: 250px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${song.display_name}</td>
            <td class="song-folder-cell" title="${getFolder(song.file_path)}" style="max-width: 140px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;"><small class="text-muted">${getFolder(song.file_path)}</small></td>
            <td class="song-album-cell" title="${song.album || ''}" style="max-width: 160px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${song.album || ''}</td>
            <td class="song-track-cell">${song.track_number || ''}</td>
            <td><small>${formatDuration(song.duration)}</small></td>
            <td style="padding: 4px; height: 40px; vertical-align: middle;">
                <!-- HARDCODED TEST BARS FOR DEBUGGING -->
                <div class="mood-bars" title="Test: Energy: ${energy}% | Valence: ${valence}% | Danceability: ${danceability}%" style="height: 32px !important; min-height: 32px !important; display: flex !important; flex-direction: column !important;">
                    <div class="mood-bar-container" style="height: 8px !important; min-height: 8px !important; background-color: #e9ecef ; margin-bottom: 2px ;">
                        <div class="energy-bar" style="width: ${energy}%; height: 8px !important; min-height: 8px !important;" title="Test Energy: ${energy}%"></div>
                    </div>
                    <div class="mood-bar-container" style="height: 8px !important; min-height: 8px !important; background-color: #e9ecef ; margin-bottom: 2px ;">
                        <div class="valence-bar" style="width: ${valence}%; height: 8px !important; min-height: 8px !important;" title="Test Valence: ${valence}%"></div>
                    </div>
                    <div class="mood-bar-container" style="height: 8px !important; min-height: 8px !important; background-color: #e9ecef ;">
                        <div class="danceability-bar" style="width: ${danceability}%; height: 8px !important; min-height: 8px !important;" title="Test Danceability: ${danceability}%"></div>
                    </div>
                </div>
            </td>
        `;
        
        // Add click event to row (but not checkbox)
        row.addEventListener('click', (e) => {
            if (!e.target.closest('input[type="checkbox"]')) {
                previewSong(song.id, row);
            }
        });
        
        tbody.appendChild(row);
    });
    
    updateBatchActionsDisplay();
    updateFilteredSongCount();
}

// Filtering and Search Functions
function populateFilterDropdowns() {
    const artists = [...new Set(songs.map(song => song.artist).filter(Boolean))].sort();
    const albums = [...new Set(songs.map(song => song.album).filter(Boolean))].sort();
    
    // Extract folder paths from file_path using the same logic as getFolder function
    const folders = [...new Set(songs.map(song => {
        if (song.file_path) {
            const parts = song.file_path.split('/');
            if (parts.length > 1) {
                parts.pop(); // Remove filename
                return parts[parts.length - 1]; // Return last folder name
            }
        }
        return null;
    }).filter(Boolean))].sort();
    
    const artistSelect = document.getElementById('artistFilter');
    const albumSelect = document.getElementById('albumFilter');
    const folderSelect = document.getElementById('folderFilter');
    
    artistSelect.innerHTML = '<option value="">All Artists</option>';
    artists.forEach(artist => {
        artistSelect.innerHTML += `<option value="${artist}">${artist}</option>`;
    });
    
    albumSelect.innerHTML = '<option value="">All Albums</option>';
    albums.forEach(album => {
        albumSelect.innerHTML += `<option value="${album}">${album}</option>`;
    });
    
    folderSelect.innerHTML = '<option value="">All Folders</option>';
    folders.forEach(folder => {
        folderSelect.innerHTML += `<option value="${folder}">${folder}</option>`;
    });
}

function setupFilterListeners() {
    const searchInput = document.getElementById('searchInput');
    const artistFilter = document.getElementById('artistFilter');
    const albumFilter = document.getElementById('albumFilter');
    const folderFilter = document.getElementById('folderFilter');
    const energyFilter = document.getElementById('energyFilter');
    const valenceFilter = document.getElementById('valenceFilter');
    const danceabilityFilter = document.getElementById('danceabilityFilter');
    const durationFilter = document.getElementById('durationFilter');
    
    searchInput.addEventListener('input', applyFilters);
    artistFilter.addEventListener('change', applyFilters);
    albumFilter.addEventListener('change', applyFilters);
    folderFilter.addEventListener('change', applyFilters);
    energyFilter.addEventListener('change', applyFilters);
    valenceFilter.addEventListener('change', applyFilters);
    danceabilityFilter.addEventListener('change', applyFilters);
    durationFilter.addEventListener('change', applyFilters);
}

function applyFilters() {
    const searchTerm = document.getElementById('searchInput').value.toLowerCase();
    const selectedArtist = document.getElementById('artistFilter').value;
    const selectedAlbum = document.getElementById('albumFilter').value;
    const selectedFolder = document.getElementById('folderFilter').value;
    const selectedEnergy = document.getElementById('energyFilter').value;
    const selectedValence = document.getElementById('valenceFilter').value;
    const selectedDanceability = document.getElementById('danceabilityFilter').value;
    const selectedDuration = document.getElementById('durationFilter').value;
    
    filteredSongs = songs.filter(song => {
        const matchesSearch = !searchTerm || 
            song.display_name.toLowerCase().includes(searchTerm) ||
            (song.artist && song.artist.toLowerCase().includes(searchTerm)) ||
            (song.album && song.album.toLowerCase().includes(searchTerm)) ||
            song.filename.toLowerCase().includes(searchTerm) ||
            (song.tags && song.tags.some(tag => tag.name.toLowerCase().includes(searchTerm)));
        
        const matchesArtist = !selectedArtist || song.artist === selectedArtist;
        const matchesAlbum = !selectedAlbum || song.album === selectedAlbum;
        
        // Check if song is in the selected folder using the same logic as getFolder
        const matchesFolder = !selectedFolder || (() => {
            if (song.file_path) {
                const parts = song.file_path.split('/');
                if (parts.length > 1) {
                    parts.pop(); // Remove filename
                    const folderName = parts[parts.length - 1]; // Get last folder name
                    return folderName === selectedFolder;
                }
            }
            return false;
        })();
        
        // Energy filter
        let matchesEnergy = true;
        if (selectedEnergy && song.energy !== null && song.energy !== undefined) {
            const energyPercent = song.energy * 100;
            if (selectedEnergy === 'high' && energyPercent < 70) matchesEnergy = false;
            if (selectedEnergy === 'medium' && (energyPercent < 30 || energyPercent >= 70)) matchesEnergy = false;
            if (selectedEnergy === 'low' && energyPercent >= 30) matchesEnergy = false;
        }
        
        // Valence (mood) filter
        let matchesValence = true;
        if (selectedValence && song.valence !== null && song.valence !== undefined) {
            const valencePercent = song.valence * 100;
            if (selectedValence === 'positive' && valencePercent < 70) matchesValence = false;
            if (selectedValence === 'neutral' && (valencePercent < 30 || valencePercent >= 70)) matchesValence = false;
            if (selectedValence === 'melancholy' && valencePercent >= 30) matchesValence = false;
        }
        
        // Danceability filter
        let matchesDanceability = true;
        if (selectedDanceability && song.danceability !== null && song.danceability !== undefined) {
            const danceabilityPercent = song.danceability * 100;
            if (selectedDanceability === 'high' && danceabilityPercent < 70) matchesDanceability = false;
            if (selectedDanceability === 'medium' && (danceabilityPercent < 30 || danceabilityPercent >= 70)) matchesDanceability = false;
            if (selectedDanceability === 'low' && danceabilityPercent >= 30) matchesDanceability = false;
        }
        
        // Duration filter
        let matchesDuration = true;
        if (selectedDuration && song.duration !== null && song.duration !== undefined) {
            if (selectedDuration === 'sound_effects' && song.duration >= 10) matchesDuration = false;
            if (selectedDuration === 'short' && song.duration >= 60) matchesDuration = false;
            if (selectedDuration === 'long' && song.duration < 60) matchesDuration = false;
        }
        
        return matchesSearch && matchesArtist && matchesAlbum && matchesFolder && 
               matchesEnergy && matchesValence && matchesDanceability && matchesDuration;
    });
    
    // Update song count display
    updateFilteredSongCount();
    
    renderSongsTable();
}

function updateFilteredSongCount() {
    const countElement = document.getElementById('filteredSongCount');
    const count = filteredSongs.length;
    countElement.textContent = `${count} song${count === 1 ? '' : 's'}`;
}

function clearFilters() {
    document.getElementById('searchInput').value = '';
    document.getElementById('artistFilter').value = '';
    document.getElementById('albumFilter').value = '';
    document.getElementById('folderFilter').value = '';
    document.getElementById('energyFilter').value = '';
    document.getElementById('valenceFilter').value = '';
    document.getElementById('danceabilityFilter').value = '';
    document.getElementById('durationFilter').value = '';
    applyFilters();
}

// Selection Functions
function toggleSongSelection(songId) {
    if (selectedSongs.has(songId)) {
        selectedSongs.delete(songId);
    } else {
        selectedSongs.add(songId);
    }
    updateBatchActionsDisplay();
    updateSelectAllCheckbox();
}

function toggleSelectAll() {
    const selectAllCheckbox = document.getElementById('selectAllCheckbox');
    const songCheckboxes = document.querySelectorAll('.song-checkbox');
    
    if (selectAllCheckbox.checked) {
        songCheckboxes.forEach(checkbox => {
            const songId = parseInt(checkbox.dataset.songId);
            selectedSongs.add(songId);
            checkbox.checked = true;
        });
    } else {
        selectedSongs.clear();
        songCheckboxes.forEach(checkbox => {
            checkbox.checked = false;
        });
    }
    
    updateBatchActionsDisplay();
}

function selectAll() {
    filteredSongs.forEach(song => selectedSongs.add(song.id));
    renderSongsTable();
}

function selectNone() {
    selectedSongs.clear();
    renderSongsTable();
}

function invertSelection() {
    const currentlySelected = new Set(selectedSongs);
    selectedSongs.clear();
    
    filteredSongs.forEach(song => {
        if (!currentlySelected.has(song.id)) {
            selectedSongs.add(song.id);
        }
    });
    
    renderSongsTable();
}

function updateSelectAllCheckbox() {
    const selectAllCheckbox = document.getElementById('selectAllCheckbox');
    const visibleSongIds = filteredSongs.map(song => song.id);
    const selectedVisibleSongs = visibleSongIds.filter(id => selectedSongs.has(id));
    
    if (selectedVisibleSongs.length === 0) {
        selectAllCheckbox.checked = false;
        selectAllCheckbox.indeterminate = false;
    } else if (selectedVisibleSongs.length === visibleSongIds.length) {
        selectAllCheckbox.checked = true;
        selectAllCheckbox.indeterminate = false;
    } else {
        selectAllCheckbox.checked = false;
        selectAllCheckbox.indeterminate = true;
    }
}

function updateBatchActionsDisplay() {
    const batchActionsCard = document.getElementById('batchActionsCard');
    const selectedCount = document.getElementById('selectedCount');
    
    if (selectedSongs.size > 0) {
        batchActionsCard.style.display = 'block';
        selectedCount.textContent = `${selectedSongs.size} song${selectedSongs.size === 1 ? '' : 's'} selected`;
    } else {
        batchActionsCard.style.display = 'none';
    }
    
    updateSelectAllCheckbox();
}

// Batch Tagging Functions
function openBatchTagModal() {
    if (selectedSongs.size === 0) {
        alert('Please select at least one song');
        return;
    }
    
    document.getElementById('batchSelectedInfo').textContent = 
        `${selectedSongs.size} song${selectedSongs.size === 1 ? '' : 's'} selected for batch tagging`;
    
    batchSelectedTags.clear();
    populateBatchTagsModal();
    
    const modal = new bootstrap.Modal(document.getElementById('batchTagModal'));
    modal.show();
}

function populateBatchTagsModal() {
    const availableContainer = document.getElementById('batchAvailableTags');
    const selectedContainer = document.getElementById('batchSelectedTags');
    
    availableContainer.innerHTML = '';
    selectedContainer.innerHTML = '';
    
    tags.forEach(tag => {
        const tagElement = document.createElement('span');
        tagElement.className = `badge me-2 mb-2 ${batchSelectedTags.has(tag.id) ? 'bg-primary' : 'bg-secondary'}`;
        tagElement.style.cursor = 'pointer';
        tagElement.textContent = tag.name;
        tagElement.onclick = () => toggleBatchTag(tag.id);
        
        if (batchSelectedTags.has(tag.id)) {
            selectedContainer.appendChild(tagElement);
        } else {
            availableContainer.appendChild(tagElement);
        }
    });
}

function toggleBatchTag(tagId) {
    if (batchSelectedTags.has(tagId)) {
        batchSelectedTags.delete(tagId);
    } else {
        batchSelectedTags.add(tagId);
    }
    populateBatchTagsModal();
}

async function applyBatchTags() {
    if (selectedSongs.size === 0) {
        alert('No songs selected');
        return;
    }
    
    if (batchSelectedTags.size === 0) {
        alert('No tags selected');
        return;
    }
    
    const operation = document.querySelector('input[name="tagOperation"]:checked').value;
    const songIds = Array.from(selectedSongs);
    const tagIds = Array.from(batchSelectedTags);
    
    try {
        const response = await fetch('/api/songs/batch-tag', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                song_ids: songIds,
                tag_ids: tagIds,
                operation: operation
            })
        });
        
        if (response.ok) {
            const result = await response.json();
            const modal = bootstrap.Modal.getInstance(document.getElementById('batchTagModal'));
            modal.hide();
            
            // Reload songs to reflect changes
            loadSongs();
            
            alert(`Successfully ${operation === 'add' ? 'added' : operation === 'replace' ? 'replaced' : 'removed'} tags for ${result.updated_count} songs`);
        } else {
            const error = await response.json();
            alert(`Error applying tags: ${error.detail}`);
        }
    } catch (error) {
        console.error('Error applying batch tags:', error);
        alert('Error applying batch tags');
    }
}

async function addSingleSong() {
    const fileInput = document.getElementById('filePathInput');
    const displayName = document.getElementById('displayName').value.trim();
    
    // Check if a file was selected using file picker
    if (fileInput.selectedFile) {
        const formData = new FormData();
        formData.append('file', fileInput.selectedFile);
        if (displayName) {
            formData.append('display_name', displayName);
        }
        
        try {
            const response = await fetch('/api/songs/upload-file', {
                method: 'POST',
                body: formData
            });
            
            if (response.ok) {
                const modal = bootstrap.Modal.getInstance(document.getElementById('addFileModal'));
                modal.hide();
                document.getElementById('addFileForm').reset();
                fileInput.selectedFile = null;
                loadSongs();
                alert('Song uploaded successfully!');
            } else {
                const error = await response.json();
                alert(`Error uploading song: ${error.detail}`);
            }
        } catch (error) {
            console.error('Error uploading song:', error);
            alert('Error uploading song');
        }
    } else {
        // Fallback to file path method
        const filePath = document.getElementById('filePath').value.trim();
        
        if (!filePath) {
            alert('Please select a file or enter a file path');
            return;
        }
        
        try {
            const response = await fetch('/api/songs/add-file', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    file_path: filePath,
                    display_name: displayName || null
                })
            });
            
            if (response.ok) {
                const modal = bootstrap.Modal.getInstance(document.getElementById('addFileModal'));
                modal.hide();
                document.getElementById('addFileForm').reset();
                loadSongs();
                alert('Song added successfully!');
            } else {
                const error = await response.json();
                alert(`Error adding song: ${error.detail}`);
            }
        } catch (error) {
            console.error('Error adding song:', error);
            alert('Error adding song');
        }
    }
}

async function addMultipleSongs() {
    const fileInput = document.getElementById('multipleFilesInput');
    
    // Check if files were selected using file picker
    if (fileInput.selectedFiles && fileInput.selectedFiles.length > 0) {
        const formData = new FormData();
        for (const file of fileInput.selectedFiles) {
            formData.append('files', file);
        }
        
        try {
            const response = await fetch('/api/songs/upload-multiple', {
                method: 'POST',
                body: formData
            });
            
            if (response.ok) {
                const result = await response.json();
                const modal = bootstrap.Modal.getInstance(document.getElementById('addMultipleModal'));
                modal.hide();
                document.getElementById('filePathsList').value = '';
                fileInput.selectedFiles = null;
                loadSongs();
                
                // Show detailed results
                let message = result.summary;
                if (result.errors.length > 0) {
                    message += '\n\nErrors:\n' + result.errors.join('\n');
                }
                alert(message);
            } else {
                const error = await response.json();
                alert(`Error uploading songs: ${error.detail}`);
            }
        } catch (error) {
            console.error('Error uploading songs:', error);
            alert('Error uploading songs');
        }
    } else {
        // Fallback to file paths method
        const filePathsText = document.getElementById('filePathsList').value.trim();
        
        if (!filePathsText) {
            alert('Please select files or enter at least one file path');
            return;
        }
        
        const filePaths = filePathsText.split('\n')
            .map(path => path.trim())
            .filter(path => path.length > 0);
        
        if (filePaths.length === 0) {
            alert('Please enter valid file paths');
            return;
        }
        
        try {
            const response = await fetch('/api/songs/add-multiple', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(filePaths)
            });
            
            if (response.ok) {
                const result = await response.json();
                const modal = bootstrap.Modal.getInstance(document.getElementById('addMultipleModal'));
                modal.hide();
                document.getElementById('filePathsList').value = '';
                loadSongs();
                
                // Show detailed results
                let message = result.summary;
                if (result.errors.length > 0) {
                    message += '\n\nErrors:\n' + result.errors.join('\n');
                }
                alert(message);
            } else {
                const error = await response.json();
                alert(`Error adding songs: ${error.detail}`);
            }
        } catch (error) {
            console.error('Error adding songs:', error);
            alert('Error adding songs');
        }
    }
}

async function scanDirectory() {
    const directoryInput = document.getElementById('directoryInput');
    const recursive = document.getElementById('recursiveScan').checked;
    
    // Check if directory was selected using directory picker
    if (directoryInput.selectedFiles && directoryInput.selectedFiles.length > 0) {
        // For directory scanning with selected files, we'll upload them directly
        const formData = new FormData();
        for (const file of directoryInput.selectedFiles) {
            formData.append('files', file);
        }
        
        try {
            const response = await fetch('/api/songs/upload-multiple', {
                method: 'POST',
                body: formData
            });
            
            if (response.ok) {
                const result = await response.json();
                const modal = bootstrap.Modal.getInstance(document.getElementById('scanDirectoryModal'));
                modal.hide();
                document.getElementById('scanDirectoryForm').reset();
                directoryInput.selectedFiles = null;
                loadSongs();
                
                // Show detailed results
                let message = `Processed directory. ${result.summary}`;
                if (result.errors.length > 0) {
                    message += '\n\nErrors:\n' + result.errors.slice(0, 10).join('\n');
                    if (result.errors.length > 10) {
                        message += `\n... and ${result.errors.length - 10} more errors`;
                    }
                }
                alert(message);
            } else {
                const error = await response.json();
                alert(`Error processing directory: ${error.detail}`);
            }
        } catch (error) {
            console.error('Error processing directory:', error);
            alert('Error processing directory');
        }
    } else {
        // Fallback to directory path method
        const directoryPath = document.getElementById('directoryPath').value.trim();
        
        if (!directoryPath) {
            alert('Please select a directory or enter a directory path');
            return;
        }
        
        try {
            const response = await fetch('/api/songs/scan-directory', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    directory_path: directoryPath,
                    recursive: recursive
                })
            });
            
            if (response.ok) {
                const result = await response.json();
                const modal = bootstrap.Modal.getInstance(document.getElementById('scanDirectoryModal'));
                modal.hide();
                document.getElementById('scanDirectoryForm').reset();
                loadSongs();
                
                // Show detailed results
                let message = result.summary;
                if (result.errors.length > 0) {
                    message += '\n\nErrors:\n' + result.errors.slice(0, 10).join('\n');
                    if (result.errors.length > 10) {
                        message += `\n... and ${result.errors.length - 10} more errors`;
                    }
                }
                alert(message);
            } else {
                const error = await response.json();
                alert(`Error scanning directory: ${error.detail}`);
            }
        } catch (error) {
            console.error('Error scanning directory:', error);
            alert('Error scanning directory');
        }
    }
}

function selectAudioFile() {
    const fileInput = document.getElementById('filePathInput');
    fileInput.onchange = function(event) {
        const file = event.target.files[0];
        if (file) {
            // For local files, we'll use the file name and path
            document.getElementById('filePath').value = file.name;
            // Store the file object for later use
            fileInput.selectedFile = file;
        }
    };
    fileInput.click();
}

function selectMultipleAudioFiles() {
    const fileInput = document.getElementById('multipleFilesInput');
    fileInput.onchange = function(event) {
        const files = Array.from(event.target.files);
        if (files.length > 0) {
            // Create a list of file names
            const fileNames = files.map(file => file.name);
            document.getElementById('filePathsList').value = fileNames.join('\n');
            // Store the files for later use
            fileInput.selectedFiles = files;
        }
    };
    fileInput.click();
}

function selectDirectory() {
    const directoryInput = document.getElementById('directoryInput');
    directoryInput.onchange = function(event) {
        const files = Array.from(event.target.files);
        if (files.length > 0) {
            // Get the common directory path from the first file
            const firstFile = files[0];
            const pathParts = firstFile.webkitRelativePath.split('/');
            pathParts.pop(); // Remove the filename
            const directoryName = pathParts.join('/');
            
            document.getElementById('directoryPath').value = directoryName || 'Selected Directory';
            // Store the files for later use
            directoryInput.selectedFiles = files;
        }
    };
    directoryInput.click();
}

function browseFile() {
    // Fallback for manual entry
    alert('Please manually enter the file path. For better experience, use the Browse button to select files directly.');
}

function browseDirectory() {
    // Fallback for manual entry
    alert('Please manually enter the directory path. For better experience, use the Browse button to select directories directly.');
}

function loadSamplePaths() {
    const samplePaths = [
        '/home/user/Music/song1.mp3',
        '/home/user/Music/album/track2.wav',
        '/home/user/Downloads/new_song.flac',
        'C:\\Music\\folder\\song.mp3',
        'C:\\Users\\User\\Music\\album\\track.wav'
    ];
    
    document.getElementById('filePathsList').value = samplePaths.join('\n');
}

function editSong(songId) {
    const song = songs.find(s => s.id === songId);
    if (!song) return;
    
    document.getElementById('editSongId').value = song.id;
    document.getElementById('editDisplayName').value = song.display_name;
    document.getElementById('editArtist').value = song.artist || '';
    document.getElementById('editAlbum').value = song.album || '';
    document.getElementById('editYear').value = song.year || '';
    document.getElementById('editGenre').value = song.genre || '';
    
    const modal = new bootstrap.Modal(document.getElementById('editModal'));
    modal.show();
}

async function updateSong() {
    const songId = document.getElementById('editSongId').value;
    const data = {
        display_name: document.getElementById('editDisplayName').value,
        artist: document.getElementById('editArtist').value,
        album: document.getElementById('editAlbum').value,
        year: parseInt(document.getElementById('editYear').value) || null,
        genre: document.getElementById('editGenre').value
    };
    
    try {
        const response = await fetch(`/api/songs/${songId}`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(data)
        });
        
        if (response.ok) {
            const modal = bootstrap.Modal.getInstance(document.getElementById('editModal'));
            modal.hide();
            loadSongs();
        } else {
            alert('Error updating song');
        }
    } catch (error) {
        console.error('Error updating song:', error);
        alert('Error updating song');
    }
}

async function previewSong(songId, rowElement) {
    // Stop all currently playing audio in the entire page
    stopAllAudio();
    
    // Remove any existing preview
    const existingPreview = document.querySelectorAll('.song-preview-row');
    existingPreview.forEach(preview => {
        // Stop any audio in the existing preview before removing
        const audioElements = preview.querySelectorAll('audio');
        audioElements.forEach(audio => {
            audio.pause();
            audio.src = '';
            if (audio.autoPlayNext) {
                audio.removeEventListener('ended', audio.autoPlayNext);
                audio.autoPlayNext = null;
            }
            if (audio.onSongEnd) {
                audio.removeEventListener('ended', audio.onSongEnd);
                audio.onSongEnd = null;
            }
        });
        preview.remove();
    });
    
    // Get song data for this row
    const song = filteredSongs.find(s => s.id === songId);
    if (!song) {
        console.error('Song not found');
        return;
    }
    
    // Format duration 
    const formatDuration = (seconds) => {
        if (!seconds) return 'Unknown';
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins}:${secs.toString().padStart(2, '0')}`;
    };
    
    // Create preview row
    const previewRow = document.createElement('tr');
    previewRow.className = 'song-preview-row';
    previewRow.innerHTML = `
        <td colspan="7">
            <div class="card border-0 bg-light">
                <div class="card-body py-3">
                    <div class="row">
                        <div class="col-md-6">
                            <div class="d-flex justify-content-between align-items-start mb-2">
                                <h6 class="mb-0">${song.display_name}</h6>
                                <button class="btn btn-sm btn-outline-secondary" onclick="editSong(${songId}); event.stopPropagation();">
                                    <i class="fas fa-edit"></i> Edit
                                </button>
                            </div>
                            <div class="text-muted small mb-2">
                                <div><strong>Filename:</strong> ${song.filename || 'Unknown'}</div>
                                <div><strong>Artist:</strong> ${song.artist || 'Unknown'}</div>
                                <div><strong>Year:</strong> ${song.year || 'Unknown'}</div>
                            </div>
                            <div class="mt-2">
                                <div class="d-flex align-items-center mb-2">
                                    <strong class="me-2 small">Tags:</strong>
                                    <button class="btn btn-sm btn-outline-success" onclick="manageTags(${songId}); event.stopPropagation();" title="Add/Remove Tags">
                                        <i class="fas fa-plus"></i>
                                    </button>
                                </div>
                                <div class="d-flex flex-wrap gap-1">
                                    ${song.tags && song.tags.length > 0 ? 
                                        song.tags.map(tag => `<span class="badge bg-secondary">${tag.name}</span>`).join('') : 
                                        '<span class="text-muted small">No tags assigned</span>'
                                    }
                                </div>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="mb-2">
                                <small class="text-muted">Song Preview</small>
                            </div>
                            <div class="mb-3">
                                <audio id="previewPlayer-${songId}" controls class="w-100"></audio>
                            </div>
                            <div class="mb-2" id="previewControls-${songId}" style="display: none;">
                                <div class="d-flex justify-content-between align-items-center mb-2">
                                    <small class="text-muted">Preview Mode</small>
                                    <button id="autoPlayToggle-${songId}" class="btn btn-sm btn-danger" onclick="toggleAutoPlay(${songId})">
                                        Stop Auto
                                    </button>
                                </div>
                                <div class="mb-2" id="segmentBar-${songId}">
                                    <small class="text-muted">Preview Segments</small>
                                    <div class="btn-group w-100 mb-2" role="group">
                                        <button class="btn btn-outline-primary segment-btn" data-segment="0" onclick="playSegment(${songId}, 0)">
                                            <div class="segment-label">Start</div>
                                        </button>
                                        <button class="btn btn-outline-primary segment-btn" data-segment="1" onclick="playSegment(${songId}, 1)">
                                            <div class="segment-label">Pre-Mid</div>
                                        </button>
                                        <button class="btn btn-outline-primary segment-btn" data-segment="2" onclick="playSegment(${songId}, 2)">
                                            <div class="segment-label">Middle</div>
                                        </button>
                                        <button class="btn btn-outline-primary segment-btn" data-segment="3" onclick="playSegment(${songId}, 3)">
                                            <div class="segment-label">Post-Mid</div>
                                        </button>
                                        <button class="btn btn-outline-primary segment-btn" data-segment="4" onclick="playSegment(${songId}, 4)">
                                            <div class="segment-label">End</div>
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </td>
    `;
    
    // Insert preview row after the current row
    rowElement.parentNode.insertBefore(previewRow, rowElement.nextSibling);
    
    // Set up the preview audio player
    const previewAudio = document.getElementById(`previewPlayer-${songId}`);
    if (previewAudio) {
        previewAudio.src = `/api/songs/${songId}/audio`;
        previewAudio.load();
        
        // Store song duration and setup preview logic
        previewAudio.addEventListener('loadedmetadata', () => {
            const duration = previewAudio.duration;
            console.log(`Song ${songId} duration: ${duration} seconds`);
            
            // Initialize audio state
            previewAudio.isAutoPlaying = true;
            previewAudio.isShortSong = duration < 30;
            
            // Check if song is short (less than 30 seconds)
            if (duration < 30) {
                // For short songs, just loop the entire song - no preview controls
                previewAudio.loop = true;
                console.log('Short song detected, enabling loop mode');
            } else {
                // For longer songs, show preview controls and setup auto-preview
                const previewControls = document.getElementById(`previewControls-${songId}`);
                if (previewControls) {
                    previewControls.style.display = 'block';
                }
                
                // Setup auto-preview system
                setupAutoPreview(songId, duration);
                
                // Add seek event listener for smart auto-preview continuation
                previewAudio.addEventListener('seeked', () => {
                    if (previewAudio.isAutoPlaying && previewAudio.segments) {
                        handleSeekDuringAutoPlay(songId);
                    }
                });
            }
        });
        
        // Add pause event listener to stop timeouts when user pauses
        previewAudio.addEventListener('pause', () => {
            console.log('Audio paused, clearing timeouts');
            if (previewAudio.segmentTimeout) {
                clearTimeout(previewAudio.segmentTimeout);
                previewAudio.segmentTimeout = null;
            }
        });
        
        // Add play event listener to resume auto-preview if in auto mode
        previewAudio.addEventListener('play', () => {
            if (previewAudio.isAutoPlaying && previewAudio.segments && !previewAudio.justSeeked) {
                console.log('Audio resumed, restarting segment timeout');
                
                // Clear any existing timeouts first
                if (previewAudio.segmentTimeout) {
                    clearTimeout(previewAudio.segmentTimeout);
                    previewAudio.segmentTimeout = null;
                }
                
                // Find current segment based on current time and resume from there
                const currentTime = previewAudio.currentTime;
                let currentSegmentIndex = 0;
                
                // Find which segment we're currently in
                for (let i = 0; i < previewAudio.segments.length; i++) {
                    const segment = previewAudio.segments[i];
                    const nextSegment = previewAudio.segments[i + 1];
                    if (currentTime >= segment.start && (!nextSegment || currentTime < nextSegment.start)) {
                        currentSegmentIndex = i;
                        break;
                    }
                }
                
                // Calculate remaining time for current segment (assume 5 seconds per segment)
                const segmentStartTime = previewAudio.segments[currentSegmentIndex].start;
                const timeIntoSegment = currentTime - segmentStartTime;
                const remainingTime = Math.max(5000 - (timeIntoSegment * 1000), 500); // At least 500ms
                
                console.log(`Resuming from segment ${currentSegmentIndex}, ${remainingTime}ms remaining`);
                
                // Update button visual state
                updateSegmentButton(songId, currentSegmentIndex);
                
                // Set timeout for remaining time in current segment
                previewAudio.segmentTimeout = setTimeout(() => {
                    if (previewAudio.isAutoPlaying) {
                        playAutoSegment(songId, currentSegmentIndex + 1);
                    }
                }, remainingTime);
            }
            
            // Reset the seek flag
            if (previewAudio.justSeeked) {
                previewAudio.justSeeked = false;
            }
        });
        
        // Store state management functions on audio element
        previewAudio.setAutoPlaying = (enabled) => {
            previewAudio.isAutoPlaying = enabled;
            const toggleButton = document.getElementById(`autoPlayToggle-${songId}`);
            if (toggleButton) {
                if (enabled) {
                    toggleButton.textContent = 'Stop Auto';
                    toggleButton.className = 'btn btn-sm btn-danger';
                } else {
                    toggleButton.textContent = 'Start Auto';
                    toggleButton.className = 'btn btn-sm btn-success';
                }
            }
        };
    }
    
    // Start auto-preview after a short delay (only for songs >= 30 seconds)
    setTimeout(() => {
        if (previewAudio && previewAudio.isAutoPlaying) {
            if (!previewAudio.isShortSong) {
                startAutoPreview(songId);
            } else {
                // For short songs, just start playing
                previewAudio.play().catch(console.error);
            }
        }
    }, 250);
}

// Global audio management functions
function stopAllAudio() {
    // Stop all preview players
    document.querySelectorAll('audio[id^="previewPlayer-"]').forEach(audio => {
        audio.pause();
        audio.currentTime = 0;
        
        // Clear any auto-preview timeouts
        if (audio.segmentTimeout) {
            clearTimeout(audio.segmentTimeout);
            audio.segmentTimeout = null;
        }
        
        // Reset auto-play state
        if (audio.isAutoPlaying !== undefined) {
            audio.isAutoPlaying = true; // Reset to default state
            if (audio.setAutoPlaying) {
                audio.setAutoPlaying(true);
            }
        }
    });
    
    // Reset all segment buttons to default state
    document.querySelectorAll('.segment-btn').forEach(btn => {
        btn.classList.remove('btn-success', 'btn-primary');
        btn.classList.add('btn-outline-primary');
    });
}

// Handler for seeking during auto-play mode
function handleSeekDuringAutoPlay(songId) {
    const previewAudio = document.getElementById(`previewPlayer-${songId}`);
    if (!previewAudio || !previewAudio.isAutoPlaying || !previewAudio.segments) {
        return;
    }
    
    console.log('Seek detected during auto-play mode');
    
    // Set flag to prevent play event from setting up conflicting timeouts
    previewAudio.justSeeked = true;
    
    // Get the current seek position and add 5 seconds
    const seekTime = previewAudio.currentTime;
    const adjustedTime = seekTime + 5;
    
    console.log(`Seek time: ${seekTime}s, adjusted time: ${adjustedTime}s`);
    
    // Clear ALL existing timeouts - this is crucial to prevent multiple timers
    if (previewAudio.segmentTimeout) {
        clearTimeout(previewAudio.segmentTimeout);
        previewAudio.segmentTimeout = null;
        console.log('Cleared existing segment timeout');
    }
    
    // Find which segment we're currently in based on the adjusted time
    let currentSegmentIndex = -1;
    const segments = previewAudio.segments;
    
    for (let i = 0; i < segments.length; i++) {
        const segment = segments[i];
        const nextSegment = segments[i + 1];
        
        // For the last segment, check if we're at or after its start
        if (i === segments.length - 1) {
            if (adjustedTime >= segment.start) {
                currentSegmentIndex = i;
            }
        } else {
            // For other segments, check if we're in the range between this segment and the next
            if (adjustedTime >= segment.start && adjustedTime < nextSegment.start) {
                currentSegmentIndex = i;
                break;
            }
        }
    }
    
    // If we couldn't determine the segment, default to the last one
    if (currentSegmentIndex === -1) {
        currentSegmentIndex = segments.length - 1;
    }
    
    console.log(`Determined we're in segment ${currentSegmentIndex} (${segments[currentSegmentIndex].name})`);
    
    // Update visual state
    updateSegmentButton(songId, currentSegmentIndex);
    
    // Store current segment index
    previewAudio.currentSegmentIndex = currentSegmentIndex;
    
    // Set up NEW timeout to play for 5 seconds then jump to next segment
    previewAudio.segmentTimeout = setTimeout(() => {
        if (previewAudio.isAutoPlaying) {
            playAutoSegment(songId, currentSegmentIndex + 1);
        }
    }, 5000);
    
    console.log(`Set up 5-second timeout to jump to next segment`);
}

// Toggle auto-play functionality
function toggleAutoPlay(songId) {
    const previewAudio = document.getElementById(`previewPlayer-${songId}`);
    const toggleButton = document.getElementById(`autoPlayToggle-${songId}`);
    
    if (!previewAudio || !toggleButton) {
        console.error('Audio player or toggle button not found');
        return;
    }
    
    if (previewAudio.isAutoPlaying) {
        // Stop auto-play mode
        console.log('Stopping auto-play mode');
        previewAudio.isAutoPlaying = false;
        
        // Clear any existing timeouts
        if (previewAudio.segmentTimeout) {
            clearTimeout(previewAudio.segmentTimeout);
            previewAudio.segmentTimeout = null;
        }
        
        // Clear segment button states
        resetSegmentButtons(songId);
        
        // Enable loop for normal playback
        previewAudio.loop = true;
        
        // Update button
        toggleButton.textContent = 'Start Auto';
        toggleButton.className = 'btn btn-sm btn-success';
        
    } else {
        // Start auto-play mode
        console.log('Starting auto-play mode');
        previewAudio.isAutoPlaying = true;
        
        // Disable loop (segments will handle progression)
        previewAudio.loop = false;
        
        // Restart auto-preview
        if (previewAudio.segments) {
            startAutoPreview(songId);
        } else if (previewAudio.duration) {
            setupAutoPreview(songId, previewAudio.duration);
            startAutoPreview(songId);
        }
        
        // Update button
        toggleButton.textContent = 'Stop Auto';
        toggleButton.className = 'btn btn-sm btn-danger';
    }
}

// New auto-preview functions
function setupAutoPreview(songId, duration) {
    console.log(`Setting up auto-preview for song ${songId} with duration ${duration}`);
    
    // Calculate segment positions based on duration
    const segments = calculateSegmentPositions(duration);
    
    const previewAudio = document.getElementById(`previewPlayer-${songId}`);
    if (previewAudio) {
        previewAudio.segments = segments;
        previewAudio.currentSegmentIndex = 0;
    }
}

function calculateSegmentPositions(duration) {
    const segments = [];
    const segmentDuration = 5; // Each segment plays for 5 seconds
    
    // Segment 0: First 5 seconds
    segments.push({ start: 0, name: 'Start' });
    
    // Segment 1: Random between (start + 5) and (middle - 5)
    const middlePoint = duration / 2;
    const randomStart1 = Math.random() * (middlePoint - 10) + 5;
    segments.push({ start: randomStart1, name: 'Pre-Mid' });
    
    // Segment 2: Middle of the song
    segments.push({ start: middlePoint - 2.5, name: 'Middle' });
    
    // Segment 3: Random between (middle + 5) and (end - 10)
    const randomStart3 = Math.random() * (duration - middlePoint - 10) + middlePoint + 5;
    segments.push({ start: randomStart3, name: 'Post-Mid' });
    
    // Segment 4: Last 5 seconds
    segments.push({ start: Math.max(duration - 5, 0), name: 'End' });
    
    console.log('Calculated segments:', segments);
    return segments;
}

function startAutoPreview(songId) {
    const previewAudio = document.getElementById(`previewPlayer-${songId}`);
    if (!previewAudio || !previewAudio.isAutoPlaying) {
        return;
    }
    
    console.log(`Starting auto-preview for song ${songId}`);
    
    // Start with the first segment
    playAutoSegment(songId, 0);
}

function playAutoSegment(songId, segmentIndex) {
    const previewAudio = document.getElementById(`previewPlayer-${songId}`);
    if (!previewAudio || !previewAudio.isAutoPlaying || !previewAudio.segments) {
        return;
    }
    
    // Clear any existing timeouts first to prevent multiple timers
    if (previewAudio.segmentTimeout) {
        clearTimeout(previewAudio.segmentTimeout);
        previewAudio.segmentTimeout = null;
    }
    
    const segments = previewAudio.segments;
    if (segmentIndex >= segments.length) {
        // Loop back to the beginning
        segmentIndex = 0;
    }
    
    const segment = segments[segmentIndex];
    console.log(`Playing auto segment ${segmentIndex} (${segment.name}) at ${segment.start}s`);
    
    // Store current segment index
    previewAudio.currentSegmentIndex = segmentIndex;
    
    // Update segment button visual state
    updateSegmentButton(songId, segmentIndex);
    
    // Set the audio position and play
    previewAudio.currentTime = segment.start;
    
    console.log("before play auto")
    previewAudio.play().then(() => {
        // Set up timeout to move to next segment after 5 seconds
        previewAudio.segmentTimeout = setTimeout(() => {
            if (previewAudio.isAutoPlaying) {
                playAutoSegment(songId, segmentIndex + 1);
            }
        }, 5000);

        console.log("after play auto")
    }).catch(console.error);
}

function updateSegmentButton(songId, segmentIndex) {
    const segmentBar = document.getElementById(`segmentBar-${songId}`);
    if (!segmentBar) return;
    
    // Reset all buttons
    const buttons = segmentBar.querySelectorAll('.segment-btn');
    buttons.forEach(btn => {
        btn.classList.remove('btn-success');
        btn.classList.add('btn-outline-primary');
    });
    
    // Highlight current button
    const currentButton = buttons[segmentIndex];
    if (currentButton) {
        currentButton.classList.remove('btn-outline-primary');
        currentButton.classList.add('btn-success');
    }
}

function resetSegmentButtons(songId) {
    // Reset all segment buttons for a specific song
    const segmentBar = document.getElementById(`segmentBar-${songId}`);
    if (segmentBar) {
        const segmentButtons = segmentBar.querySelectorAll('.segment-btn');
        segmentButtons.forEach(btn => {
            btn.classList.remove('btn-success', 'btn-primary');
            btn.classList.add('btn-outline-primary');
        });
    }
}

function playSegment(songId, segment) {
    try {
        const audio = document.getElementById(`previewPlayer-${songId}`);
        if (!audio) {
            console.error('Preview player not found');
            return;
        }
        
        // Only allow manual segment selection if auto-play is enabled
        if (!audio.isAutoPlaying) {
            console.log('Manual segment selection disabled in manual mode');
            return;
        }
        
        // Clear any existing timeouts
        if (audio.segmentTimeout) {
            clearTimeout(audio.segmentTimeout);
            audio.segmentTimeout = null;
        }
        
        // If we don't have segments calculated yet, calculate them
        if (!audio.segments && audio.duration) {
            audio.segments = calculateSegmentPositions(audio.duration);
        }
        
        // Check if segments are available
        if (!audio.segments || segment >= audio.segments.length) {
            console.error('Segments not available or invalid segment index');
            return;
        }
        
        const segmentData = audio.segments[segment];
        console.log(`Manual segment play: ${segment} (${segmentData.name}) at ${segmentData.start}s`);
        
        // Store current segment index
        audio.currentSegmentIndex = segment;
        
        // Update button visual state
        updateSegmentButton(songId, segment);
        
        // Seek to the segment position and play
        audio.currentTime = segmentData.start;
        audio.play().then(() => {
            // Set up timeout to continue auto-preview from this segment
            audio.segmentTimeout = setTimeout(() => {
                if (audio.isAutoPlaying) {
                    playAutoSegment(songId, segment + 1);
                }
            }, 5000);
        }).catch(error => {
            console.error('Error playing audio:', error);
            alert('Error playing audio preview. The file may not exist or be accessible.');
        });
        
    } catch (error) {
        console.error('Error in playSegment:', error);
        alert('Error loading audio preview.');
    }
}

function closePreview() {
    // This function is now deprecated since previews auto-close when new ones are selected
    // But keeping it for compatibility with any existing calls
    const previewContainers = document.querySelectorAll('.song-preview-row');
    previewContainers.forEach(container => {
        // Stop any playing audio and clean up event listeners
        const audioElements = container.querySelectorAll('audio');
        audioElements.forEach(audio => {
            audio.pause();
            audio.src = '';
            
            // Clear new timeout properties
            if (audio.segmentTimeout) {
                clearTimeout(audio.segmentTimeout);
                audio.segmentTimeout = null;
            }
        });
        
        container.remove();
    });
}

async function deleteSong(songId) {
    const song = songs.find(s => s.id === songId);
    if (!song) return;
    
    // Store the song data and row for potential undo
    deletedSong = { ...song };
    const row = document.querySelector(`input[data-song-id="${songId}"]`).closest('tr');
    deletedSongRow = row.cloneNode(true);
    
    // Remove the song from the UI immediately
    row.style.opacity = '0.5';
    row.classList.add('table-secondary');
    
    // Remove from arrays
    songs = songs.filter(s => s.id !== songId);
    filteredSongs = filteredSongs.filter(s => s.id !== songId);
    selectedSongs.delete(songId);
    updateBatchActionsDisplay();
    
    // Show undo notification
    showUndoNotification(song.display_name);
    
    // Start the actual deletion process after a delay
    undoTimeout = setTimeout(async () => {
        try {
            const response = await fetch(`/api/songs/${songId}`, {
                method: 'DELETE'
            });
            
            if (response.ok) {
                // Remove the row from DOM
                row.remove();
                hideUndoNotification();
            } else {
                // If deletion failed, restore the song
                restoreSong();
                alert('Error deleting song from server');
            }
        } catch (error) {
            console.error('Error deleting song:', error);
            restoreSong();
            alert('Error deleting song');
        }
        
        // Clear undo data
        deletedSong = null;
        deletedSongRow = null;
        undoTimeout = null;
    }, 5000); // 5 second delay
}

function showUndoNotification(songName) {
    const notification = document.getElementById('undoNotification');
    const message = document.getElementById('undoMessage');
    const progressBar = document.getElementById('undoProgressBar');
    
    message.textContent = `"${songName}" deleted`;
    
    // Reset and show notification
    notification.style.display = 'block';
    notification.classList.add('show');
    
    // Reset and start progress bar animation
    progressBar.style.transition = 'none';
    progressBar.style.width = '100%';
    
    // Force reflow then start animation
    progressBar.offsetHeight;
    progressBar.style.transition = 'width 5s linear';
    progressBar.style.width = '0%';
}

function hideUndoNotification() {
    const notification = document.getElementById('undoNotification');
    notification.classList.remove('show');
    setTimeout(() => {
        notification.style.display = 'none';
    }, 150);
}

function undoDelete() {
    if (undoTimeout && deletedSong && deletedSongRow) {
        // Cancel the deletion
        clearTimeout(undoTimeout);
        undoTimeout = null;
        
        // Restore the song
        restoreSong();
        
        // Hide notification
        hideUndoNotification();
    }
}

function restoreSong() {
    if (!deletedSong || !deletedSongRow) return;
    
    // Add song back to arrays
    songs.push(deletedSong);
    
    // Re-apply filters and render
    applyFilters();
    
    // Clear undo data
    deletedSong = null;
    deletedSongRow = null;
}

function manageTags(songId) {
    const song = songs.find(s => s.id === songId);
    if (!song) return;
    
    document.getElementById('tagManagementSongId').value = songId;
    loadSongTags(songId);
    
    const modal = new bootstrap.Modal(document.getElementById('tagManagementModal'));
    modal.show();
}

async function loadSongTags(songId) {
    try {
        console.log('Loading tags for song ID:', songId);
        
        // Get the song with its current tags
        const songResponse = await fetch(`/api/songs/${songId}`);
        if (!songResponse.ok) {
            throw new Error(`Failed to fetch song: ${songResponse.status}`);
        }
        const song = await songResponse.json();
        console.log('Song data:', song);
        
        // Get all available tags
        const tagsResponse = await fetch('/api/tags/');
        if (!tagsResponse.ok) {
            throw new Error(`Failed to fetch tags: ${tagsResponse.status}`);
        }
        const allTags = await tagsResponse.json();
        console.log('All tags:', allTags);
        
        // Display current tags
        const currentTagsDiv = document.getElementById('currentTags');
        currentTagsDiv.innerHTML = '';
        
        if (song.tags && song.tags.length > 0) {
            song.tags.forEach(tag => {
                const tagSpan = document.createElement('span');
                tagSpan.className = 'badge bg-primary position-relative me-2 mb-2';
                tagSpan.innerHTML = `
                    ${tag.name}
                    <button type="button" class="btn-close btn-close-white ms-1" 
                            style="font-size: 0.6em;" onclick="removeTagFromSong(${songId}, ${tag.id})"></button>
                `;
                currentTagsDiv.appendChild(tagSpan);
            });
        } else {
            currentTagsDiv.innerHTML = '<span class="text-muted">No tags assigned</span>';
        }
        
        // Display available tags
        const availableTagsDiv = document.getElementById('availableTags');
        availableTagsDiv.innerHTML = '';
        
        const currentTagIds = song.tags ? song.tags.map(tag => tag.id) : [];
        const availableTags = allTags.filter(tag => !currentTagIds.includes(tag.id));
        
        if (availableTags.length > 0) {
            availableTags.forEach(tag => {
                const tagButton = document.createElement('button');
                tagButton.className = 'btn btn-sm btn-outline-secondary me-2 mb-2';
                tagButton.textContent = tag.name;
                tagButton.onclick = () => addTagToSong(songId, tag.id);
                availableTagsDiv.appendChild(tagButton);
            });
        } else {
            availableTagsDiv.innerHTML = '<span class="text-muted">All tags are already assigned</span>';
        }
        
    } catch (error) {
        console.error('Error loading song tags:', error);
        alert('Error loading song tags: ' + error.message);
    }
}

async function addTagToSong(songId, tagId) {
    try {
        console.log(`Adding tag ${tagId} to song ${songId}`);
        const response = await fetch(`/api/songs/${songId}/tags/${tagId}`, {
            method: 'POST'
        });
        
        if (response.ok) {
            console.log('Tag added successfully');
            await loadSongTags(songId); // Refresh the tag display
            await loadSongs(); // Refresh the main songs table
        } else {
            const errorText = await response.text();
            console.error('Error response:', errorText);
            alert('Error adding tag to song: ' + errorText);
        }
    } catch (error) {
        console.error('Error adding tag to song:', error);
        alert('Error adding tag to song: ' + error.message);
    }
}

async function removeTagFromSong(songId, tagId) {
    try {
        console.log(`Removing tag ${tagId} from song ${songId}`);
        const response = await fetch(`/api/songs/${songId}/tags/${tagId}`, {
            method: 'DELETE'
        });
        
        if (response.ok) {
            console.log('Tag removed successfully');
            await loadSongTags(songId); // Refresh the tag display
            await loadSongs(); // Refresh the main songs table
        } else {
            const errorText = await response.text();
            console.error('Error response:', errorText);
            alert('Error removing tag from song: ' + errorText);
        }
    } catch (error) {
        console.error('Error removing tag from song:', error);
        alert('Error removing tag from song: ' + error.message);
    }
}

function addToPlaylist(songId) {
    document.getElementById('addToPlaylistSongId').value = songId;
    const modal = new bootstrap.Modal(document.getElementById('addToPlaylistModal'));
    modal.show();
}

async function addSongToSelectedPlaylist() {
    const songId = document.getElementById('addToPlaylistSongId').value;
    const playlistId = document.getElementById('playlistSelectDropdown').value;
    
    if (!playlistId) {
        alert('Please select a playlist');
        return;
    }
    
    try {
        const response = await fetch(`/api/playlists/${playlistId}/songs/${songId}`, {
            method: 'POST'
        });
        
        if (response.ok) {
            const modal = bootstrap.Modal.getInstance(document.getElementById('addToPlaylistModal'));
            modal.hide();
            
            const song = songs.find(s => s.id == songId);
            const playlist = playlists.find(p => p.id == playlistId);
            alert(`"${song.display_name}" added to playlist "${playlist.name}"`);
        } else {
            const errorText = await response.text();
            alert('Error adding song to playlist: ' + errorText);
        }
    } catch (error) {
        console.error('Error adding song to playlist:', error);
        alert('Error adding song to playlist: ' + error.message);
    }
}

// Batch Operations Functions
function openBatchPlaylistModal() {
    if (selectedSongs.size === 0) {
        alert('No songs selected');
        return;
    }
    
    const modal = new bootstrap.Modal(document.getElementById('batchPlaylistModal'));
    modal.show();
}

async function applyBatchPlaylist() {
    if (selectedSongs.size === 0) {
        alert('No songs selected');
        return;
    }
    
    const playlistId = document.getElementById('batchPlaylistSelect').value;
    if (!playlistId) {
        alert('Please select a playlist');
        return;
    }
    
    const songIds = Array.from(selectedSongs);
    let successCount = 0;
    let errors = [];
    
    try {
        for (const songId of songIds) {
            try {
                const response = await fetch(`/api/playlists/${playlistId}/songs/${songId}`, {
                    method: 'POST'
                });
                
                if (response.ok) {
                    successCount++;
                } else {
                    const errorText = await response.text();
                    errors.push(`Song ID ${songId}: ${errorText}`);
                }
            } catch (error) {
                errors.push(`Song ID ${songId}: ${error.message}`);
            }
        }
        
        const modal = bootstrap.Modal.getInstance(document.getElementById('batchPlaylistModal'));
        modal.hide();
        
        let message = `Successfully added ${successCount} songs to playlist`;
        if (errors.length > 0) {
            message += `\n\nErrors (${errors.length}):\n${errors.slice(0, 5).join('\n')}`;
            if (errors.length > 5) {
                message += `\n... and ${errors.length - 5} more`;
            }
        }
        alert(message);
        
        // Clear selection
        selectedSongs.clear();
        updateBatchActionsVisibility();
        
        // Update checkboxes
        document.querySelectorAll('.song-checkbox').forEach(cb => cb.checked = false);
        
    } catch (error) {
        console.error('Error applying batch playlist:', error);
        alert('Error applying batch playlist: ' + error.message);
    }
}

async function batchDeleteSongs() {
    if (selectedSongs.size === 0) {
        alert('No songs selected');
        return;
    }
    
    const songIds = Array.from(selectedSongs);
    const songsToDelete = songs.filter(s => songIds.includes(s.id));
    
    // Store undo data
    undoData = {
        action: 'delete',
        songs: songsToDelete.map(s => ({...s})) // Deep copy
    };
    
    // Clear any existing undo timeout
    if (undoTimeout) {
        clearTimeout(undoTimeout);
    }
    
    // Remove songs from display immediately
    songs = songs.filter(s => !songIds.includes(s.id));
    renderSongsTable();
    
    // Clear selection
    selectedSongs.clear();
    updateBatchActionsVisibility();
    
    // Show undo notification
    showUndoNotification('Songs will be deleted in 5 seconds', () => undoBatchDelete());
    
    // Set timeout to actually delete
    undoTimeout = setTimeout(async () => {
        await performBatchDelete(songIds);
        undoData = null;
    }, 5000);
}

async function performBatchDelete(songIds) {
    let successCount = 0;
    let errors = [];
    
    try {
        for (const songId of songIds) {
            try {
                const response = await fetch(`/api/songs/${songId}`, {
                    method: 'DELETE'
                });
                
                if (response.ok) {
                    successCount++;
                } else {
                    const errorText = await response.text();
                    errors.push(`Song ID ${songId}: ${errorText}`);
                }
            } catch (error) {
                errors.push(`Song ID ${songId}: ${error.message}`);
            }
        }
        
        let message = `Successfully deleted ${successCount} songs`;
        if (errors.length > 0) {
            message += `\n\nErrors (${errors.length}):\n${errors.slice(0, 5).join('\n')}`;
            if (errors.length > 5) {
                message += `\n... and ${errors.length - 5} more`;
            }
            
            // If there were errors, reload songs to show what actually exists
            await loadSongs();
        }
        
        if (successCount > 0 || errors.length > 0) {
            alert(message);
        }
        
    } catch (error) {
        console.error('Error performing batch delete:', error);
        alert('Error deleting songs: ' + error.message);
        // Reload songs on error
        await loadSongs();
    }
}

function undoBatchDelete() {
    if (!undoData || undoData.action !== 'delete') {
        return;
    }
    
    // Clear the timeout
    if (undoTimeout) {
        clearTimeout(undoTimeout);
        undoTimeout = null;
    }
    
    // Restore songs to display
    songs.push(...undoData.songs);
    songs.sort((a, b) => a.id - b.id); // Re-sort by ID
    renderSongsTable();
    
    // Clear undo data
    undoData = null;
    
    // Hide undo notification
    hideUndoNotification();
    
    alert('Delete operation cancelled');
}

function showUndoNotification(message, undoCallback) {
    // Create or update undo notification
    let notification = document.getElementById('undoNotification');
    if (!notification) {
        notification = document.createElement('div');
        notification.id = 'undoNotification';
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #28a745;
            color: white;
            padding: 15px 20px;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 9999;
            display: flex;
            align-items: center;
            gap: 15px;
        `;
        document.body.appendChild(notification);
    }
    
    notification.innerHTML = `
        <span>${message}</span>
        <button onclick="undoBatchDelete()" style="
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
        ">Undo</button>
    `;
    notification.style.display = 'flex';
}

function hideUndoNotification() {
    const notification = document.getElementById('undoNotification');
    if (notification) {
        notification.style.display = 'none';
    }
}
</script>
{% endblock %}
